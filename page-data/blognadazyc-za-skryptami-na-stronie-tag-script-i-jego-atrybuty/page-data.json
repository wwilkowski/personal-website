{"componentChunkName":"component---src-templates-blog-post-js","path":"/blognadazyc-za-skryptami-na-stronie-tag-script-i-jego-atrybuty","result":{"data":{"site":{"siteMetadata":{"title":"Wojciech Wilkowski","author":"@wwilkowski"}},"datoCmsArticle":{"id":"DatoCmsArticle-23561383-en","title":"Nadążyć za skryptami na stronie - tag script i jego atrybuty","date":"13 listopada 2019","description":"Problem ładowania skryptów na stronie internetowej to zagadnienie, o które pytano i wciąż pyta się wielokrotnie. Sam w ciągu ostatniego miesiąca spotkałem się kilkukrotnie z prośbą o rozwiązanie problemu zbyt wczesnego ładowania skryptów.","content":"## Scenariusz problemu\n\nNajczęściej spotykanym problemem dotyczącym ładowania skryptów jest sytuacja, w której za pośrednictwem kodu w Javascript, ktoś chce pobrać element DOM, na przykład za pośrednictwem funkcji `querySelector(\".klasaElementu\")`i wykonać na nim pewne operacje.\n\nMimo, że w strukturze HTML element o podanej klasie istnieje, to próba jego pobrania kończy się _niespodziewanym_ __`null`__.\n\n## Analiza strony przez przeglądarkę\n\nGdy przeglądarka ładuje zawartość strony i natrafi na tag `<script>`, to przerywa dalsze ładowanie dokumentu do momentu końca pobierania i wykonania skryptu, na który natrafiła.\n\nTo daje nam odpowiedź na pytanie, dlaczego zdarza się, że skrypt nie widzi elementów DOM, które istnieją (istnieją w dokumencie, lecz nie zostały jeszcze załadowane, przeglądarka nie wie o ich istnieniu). Dodatkowy skutek uboczny tego działania to problem zbyt długiego ładowania strony, gdy zawiera ona duży, wymagający długiego czasu uruchomienia skrypt.\n\n## Zdarzenie DOMContentLoaded\n\n\n```javascript\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  console.log(\"DOM content is loaded!\"); \n  // ... ale nie mamy informacji o stanie załadowania np. arkuszy stylów\n});\n```\n\nZwróćmy na moment uwagę na zdarzenie, w odnieseniu do którego przeanalizujemy możliwości wykonywania skryptów.\n\nMa ono miejsce w momencie, gdy cały dokument HTML zostanie załadowany i przeanalizowany przez przeglądarkę (nie uwzględnia ładowania arkuszy stylów, obrazów i ramek(`<iframe>`));\n\n### Czy`load` to alternatywa dla `DOMContentLoaded`?\n\n```javascript\nwindow.addEventListener(\"load\", () => {\n  console.log(\"Load event!\");\n  // ... teraz wiemy dużo więcej!\n});\n```\n\nCzasami możemy spotkać się z praktyką zastępowania zdarzenia `DOMContentLoaded` zdarzeniem `load`, co jest __błędem__ i wskazuje na błędne rozumienie działania tych zdarzeń. \n\nJak już wspomniałem, `DOMContentLoaded` oczekuje na __wczytanie struktury dokumentu__, podczas gdy zdarzenie `load` oczekuje również na takie sytuacje, jak na przykład __załadowanie grafik__, co przy materiałach o większym rozmiarze stanowczo spowolni proces pełnego załadowania strony.\n\nWnioskiem, jaki możemy tutaj wysnuć jest fakt, że zdarzenie `load` nastąpi nie wcześniej, niż po zdarzeniu `DOMContentLoaded`.\n\n## Możliwe rozwiązania problemu\n\nOprócz oczekiwania na zdarzenie `DOMContentLoaded `istnieje jeszcze kilka opcji opanowania dołączanych przez nas skryptów, aby mieć nad nimi pełną (_lub prawie pełną [#async]_) kontrolę.\n\n### Umieszczenie tagów `<script>` na końcu dokumentu\n\n```html\n<body>\n    ...\n    <script src='./scripts_1.js'></script>\n</body>\n```\n\nWtedy faktycznie skrypt wykona się dopiero po załadowaniu całego drzewa DOM, gdyż dopiero wtedy przeglądarka na niego natrafi. Ma to jednak swoje minusy w momencie, gdy kod naszej strony jest długi. Minie wtedy sporo czasu, zanim przeglądarka przebrnie przez strukturę strony i będzie mogła zająć się obsługą skryptów.\n\n### Atrybut `defer`\n\n```html \n<head>\n    ...\n    <script defer src='./defer1.js'></script>\n</head>\n```\n\nDodanie atrybutu `defer` możemy rozumieć jako rozkaz dla przeglądarki: _wczytuj dalszą część dokumentu, a ładowanie skryptu wykonuj \"w tle\". Uruchom skrypt, gdy załadujesz wszystkie skrypty z tym atrybutem oraz strukturę strony._\n\nW praktyce scenariusz ładowania strony będzie wyglądał następująco:\n\n- przeglądarka rozpoczyna wczytywanie dokumentu\n- gdy natrafi na tag ``<script defer ...></script>`` przenosi jego wczytywanie w tło i kontynuuje wczytywanie dokumentu\n- gdy wczytywanie skryptów w tle się zakończy, następuje oczekiwanie na zakończenie ładowania dokumentu\n- gdy przeglądarka w pełni wczyta dokument (ale __przed__ zdarzeniem `DOMContentLoaded`), uruchamia załadowane skrypty\n- po uruchomieniu skryptów następuje zdarzenie `DOMContentLoaded`\n\n> __Uwaga:__ atrybutu `defer` możemy używać jedynie dla skryptów zewnętrznych (wczytywanych z zewnętrznych plików).\n\nScenariusz ten sprawi, że skrypt z atrybutem `defer`, mimo, że wykona się przed zdarzeniem `DOMContentLoaded`, to będzie miał już dostęp i informację o elementach z drzewa DOM.\n\nDodajmy na stronie dwa skrypty. Pierwszy skrypt bez żadnych atrybutów, drugi z atrybutem defer. Oba skrypty umieśćmy wewnątrz znacznika `<head></head>` oraz zamieśćmy w obu identyczny kod.\n\n```html \n<head>\n    <script src='./scripts_1.js'></script>\n    <script defer src='./defer1.js'></script>\n</head>\n<body>\n    <h1 class='title'>Title from HTML document!</h1>\n</body>\n```\n\n```javascript\nconsole.log(`Element: ${document.querySelector(\".title\")}`);\n```\n\nW wyniku takiego działania, w konsoli przeglądarki otrzymamy:\n```\nElement: null\nElement: [object HTMLHeadingElement]\n```\n\nZ opisanych przeze mnie wcześniej względów potwierdziliśmy, że zwykły skrypt nie poradził sobie z pobraniem elementu, za to skrypt z atrybutem `defer` nie miał z tym problemu.\n\nDodajmy teraz do zwykłego skryptu nasłuchiwanie na zdarzenie załadowania dokumentu:\n\n```javascript\nconsole.log(`Element: ${document.querySelector(\".title\")}`);\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  console.log(\"DOMContentLoaded!\");\n});\n```\n\nWynik w konsoli będzie następujący:\n```\nElement: null\nElement: [object HTMLHeadingElement]\nDOMContentLoaded\n```\n\nJak widzimy, skrypt `defer` uzyskał dostęp do pełni dokumentu, zanim nastąpiło zdarzenie potwierdzające jego załadowanie.\n\n\n### Async\n\n```html\n<script async src='./async.js'></script>\n```\n\nDodając do znacznika `<script>` atrybut `async`, informujemy przeglądarkę, że ma do czynienia ze skryptem, który powinien być w pełni niezależny od pozostałej części dokumentu.\n\nW praktyce przeglądarka, natrafiając na tag `<script async...></script>`, podobnie jak w poprzednim przypadku odłoży ładowanie skryptu w tło i zajmie się dalszym wczytywaniem dokumentu.\n\nRóżnica pojawia się w momencie, gdy skrypt zostanie załadowany.\nW odróżnieniu od skryptów z atrybutem `defer`, skrypt oznaczony atrybutem `async` uruchomi się zaraz po załadowaniu.\n\nOpisane zachowanie skryptu sprawia, że __nie jesteśmy w stanie jednoznacznie określić, czy niezależny skrypt wykona się przed, czy po zdarzeniu `DOMContentLoaded`__.\n\nDodajmy teraz do naszej strony dwa skrypty:\n\n```html \n<head>\n    ...\n    <script async src='./async.js'></script>\n    <script src='./scripts_1.js'></script>\n</head>\n```\n\nZostawmy w pliku `scripts_1.js` nasłuchiwanie na zdarzenie `DOMContentLoaded`:\n\n```javascript\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  console.log(\"DOMContentLoaded!\");\n});\n```\n\nOraz umieśćmy `console.log` w skrypcie z atrybutem async:\n```javascript\nconsole.log(\"Hello from async script!\");\n```\n\nZaobserwujemy, że odświeżając stronę, w konsoli przeglądarki będą pojawiały się odpowiednie logi, jednak ich kolejność będzie losowa. W kolejnych odświeżeniach otrzymamy:\n\n```\nDOMContentLoaded!\nHello from async script!\n```\n\nlub\n\n```\nHello from async script!\nDOMContentLoaded!\n```\n\nco wskazuje na niezależność skryptu.\n \nDodatkowo, jeżeli dołączymy do strony kilka skryptów z atrybutem `async`, to uruchomią się one w takiej kolejności, w jakiej się załadowały. W przeciwieństwie do skryptów z atrybutem `defer`, nie będą one na siebie wzajemnie oczekiwały.\n\n#### _Use case_ dla skryptów asynchronicznych\n\nBiorąc pod uwagę specyfikę skryptów z atrybutem `async` jasne jest, że nie powinniśmy ich używać do operacji na załadowanej strukturze strony.\n\nZnajdują one zastosowanie w skryptach niezależnych od struktury dokumentu, na przykład w skryptach ładujących reklamy lub pobierających pewne statystyki.\n","tags":"[\n  \"html\",\n  \"javascript\"\n]","slug":"nadazyc-za-skryptami-na-stronie-tag-script-i-jego-atrybuty"}},"pageContext":{"slug":"nadazyc-za-skryptami-na-stronie-tag-script-i-jego-atrybuty","previous":{"slug":"porozumienie-gatsby-wordpress","title":"Porozumienie Gatsby-Wordpress"},"next":null}},"staticQueryHashes":["3649515864","63159454"]}