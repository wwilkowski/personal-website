{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/porozumienie-gatsby-wordpress","result":{"data":{"site":{"siteMetadata":{"title":"Wojciech Wilkowski","author":"@wwilkowski"}},"datoCmsArticle":{"id":"DatoCmsArticle-23561396-en","title":"Porozumienie Gatsby-Wordpress","date":"25 września 2019","description":"Wordpress, jako system zarządzania treścią, od lat cieszy się ogromną popularnością, jednak w ostatnim czasie możemy zaobserwować trend na tworzenie stron oraz blogów przy użyciu generatora stron statycznych o nazwie Gatsby. W artykule pokażę więc jak poradzić sobie, gdy trend nas przekona, lecz klient jest silnie przywiązany do panelu administracyjnego Wordpress.","content":"Gatsby, czyli generator stron statycznych nazywany przez niektorych _następcą Wordpressa_ to narzędzie, które zyskało ostatnio wielką popularność. \nIlość repozytoriów na Github, które z niego korzystają to ponad sto tysięcy.\n\nWraz z Wordpressem może on stworzyć duet, który choć na początku nie wydawał mi się godny uwagi, to ostatecznie okazał się znakomitym rozwiązaniem.\n\n## Narzędzia, których będziemy potrzebować\n\n### Wordpress\n\nNa potrzeby artykułu zakładam, że jesteś w stanie zainstalować Wordpressa na dowolnym hostingu. Ja posłużę się darmowym hostingiem [cba.pl](https://www.cba.pl/pl). Jeśli masz jakieś wątpliwości, zajrzyj na [stronę poświęconą temu zagadnieniu](https://www.cba.pl/pl/oferta/hosting/hosting-wordpress).\n\nUtwórz na przykład domenę __`<nazwa_uzytkownika>.cba.pl/mywordpressblog`__ i zainstaluj tam system Wordpress.\n\n### Gatsby\n\nJeśli nigdy wcześniej nie korzystałeś z Gatsbiego, to podążając za dokumentacją wystarczy, że zainstalujesz go globalnie poleceniem\n```shell\nnpm install -g gatsby-cli\n```\n\nOd tej pory możesz tworzyć projekty używając polecenia\n```shell\ngatsby new <nazwa_strony>\n```\n\nNa tym etapie polecam jednak skorzystanie z szablonów przygotowanych przez innych programistów, aby otrzymać już pewną, gotową do pracy strukturę projektu.\n\n> Listę szablonów znajdziesz [TUTAJ](https://www.gatsbyjs.org/starters/?v=2)\n\nNa potrzeby tego poradnika skorzystamy z najbardziej podstawowego szablonu, jakim jest [gatsby-starter-default](https://www.gatsbyjs.org/starters/gatsbyjs/gatsby-starter-default/).\n\nAby go pobrać i zainicjować projekt, używamy polecenia\n```shell\ngatsby new <nazwa_strony> https://github.com/gatsbyjs/gatsby-starter-default\n```\noraz przechodzimy do utworzonego folderu.\n\n\n\n### Gitlab\n\nJest to menedżer repozytoriów, który umożliwi nam przechowywanie aktualnej wersji naszej strony, jej aktualizację oraz hosting za pośrednictwem [Gitlab Pages](https://docs.gitlab.com/ee/user/project/pages/).\n\nPo założeniu konta w serwisie, tworzymy nowy projekt. Wystarczy, że uzupełnimy nazwę projektu (w moim przypadku będzie to __mywordpressblog__) oraz automatycznie zaproponowany adres [https://gitlab.com/wglugla/mywordpressblog](https://gitlab.com/wglugla/mywordpressblog)).\n\nTeraz wystarczy użyć przycisku __clone__ i skopiować link z sekcji __Clone with HTTPS__.\n\nW folderze, gdzie znajduje się utworzony przez nas projekt Gatsby, inicjujemy repozytorium\n```shell\ngit init\ngit add .\ngit commit -m \"Initial commit\"\n```\noraz dodajemy zdalne repozytorium. W moim przypadku będą to polecenia:\n\n```shell\ngit remote add origin https://gitlab.com/wglugla/mywordpressblog.git\ngit push -u origin master\n```\n\n## Konfiguracja projektu\n\nPo wywołaniu polecenia \n```shell\ngatsby develop\n```\n\nna stronie __localhost:8000__ powinniśmy ujrzeć aktualną wersję strony.\n\n![](https://i.imgur.com/zTGR1Jg.png)\n\n> __WAŻNE:__ Port może ulec zmianie (na przykład, jeśli 8000 jest zajęty). Informację na ten temat można znaleźć po uruchomieniu serwera.\n\nPodstawowe informacje, takie jak autor, tytuł bloga lub jego opis możesz uzupełnić w pliku __gatsby-config.js__ znajdującym się w folderze głównym projektu.\n\n## Pobranie danych z Wordpressa\n\nPierwszym celem na naszej stronie będzie wyświetlenie listy postów, które zostały przez nas utworzone.\nPosłużymy się w tym celu pluginem [gatsby-source-wordpress](https://www.gatsbyjs.org/packages/gatsby-source-wordpress/). Pozwoli on nam na pobranie danych JSON z Wordpressa.\n\nInstalacja przebiega bardzo prosto, wystarczy użyć polecenia\n```shell\nnpm install --save gatsby-source-wordpress\n```\n\na następnie w pliku konfiguracyjnym __gatsby-config.js__ dodać ten plugin zgodnie z podstawową konfiguracją zaproponowaną w dokumentacji.\n\n```javascript\n{\n  resolve: 'gatsby-source-wordpress',\n  options: {\n    // The base url to your WP site.\n    // baseUrl: 'wpdemo.gatsbycentral.com',\n    baseUrl: 'wglugla.cba.pl',\n    // WP.com sites set to true, WP.org set to false\n    hostingWPCOM: false,\n    // The protocol. This can be http or https.\n    protocol: 'http',\n    // Use 'Advanced Custom Fields' Wordpress plugin\n    useACF: false,\n    auth: {},\n    // Set to true to debug endpoints on 'gatsby build'\n    verboseOutput: false,\n  },\n},\n```\n\n> W miejscu __baseUrl__ należy dodać adres swojej strony.\n\nPo edycji pliku __gatsby-config__ musimy ponownie uruchomić projekt poleceniem \n\n```shell\ngatsby develop\n```\n\nAby przetestować, czy wszystko poszło po naszej myśli, przejdźmy pod adres **localhost:8000/__graphql**\n\nZnajdziemy tam narzędzie pozwalające na testowanie zapytań Graphql, zanim użyjemy ich w naszej aplikacji.\n\n> Jeśli nie wiesz czym jest GraphQL lub nie czujesz się na siłach, aby samemu zrozumieć jak on działa, gorąco zachęcam Cię do obejrzenia filmu lub całej serii na Youtube stworzonej przez __overmenta__. Listę serii o GraphQL znajdziesz [TUTAJ](https://www.youtube.com/playlist?list=PLjHmWifVUNMLivTPinla41NWyYf3pONIa).\n\n> Dodam, że wystarczy naprawdę podstawowa wiedza na temat działania zapytań GraphQL, abyśmy byli w stanie uzyskać potrzebne informacje.\n\nDla testów, w polu tekstowym wpiszmy\n```graphql\nquery IndexQuery {\n  allWordpressPost {\n    edges {\n      node {\n        title\n        slug\n        content\n      }\n    }\n  }\n}\n```\n\nPo wciśnięciu kombinacji __ctrl + enter__ naszym oczom powinien ukazać się wynik zapytania zawierający informacje o aktualnie istniejących postach.\n\n![](https://i.imgur.com/jHrmeO3.png)\n\n## Jaką ścieżkę nadać wpisom\n\nSposobem na prezentację wpisów na blogu będzie pobranie wszystkich artykułów, a następnie wygenerowanie, według szablonu, odpowiedniej podstrony dla każdego z nich.\n\nAby wszystko poszło sprawnie, należy przyjąć jedną zasadę, na podstawie której tworzone będą nazwy stron. Posłużymy się w tym celu właściwością __slug__, która stworzona będzie z tytułu artykułu, gdzie każde słowo napisane będzie małymi literami i oddzielone myślnikami.\nW tym celu musimy skonfigurować tę właściwość w ustawieniach Wordpressa.\n\nPo zalogowaniu do panelu administratora wchodzimy w __Ustawienia -> Bezpośrednie odnośniki__ i wybieramy opcję __nazwa wpisu http://wglugla.cba.pl/przykladowy-wpis/__, po czym zapisujemy zmiany.\n\n## Lista wpisów na blogu\n\nAby wylistować tytuły wszystkich wpisów, utworzymy komponent, który będzie pełnił funkcję szablonu, dzięki któremu Gatsby wygeneruje stronę główną dodając do niej pobrane dane.\n\nW folderze __src__ naszego projektu, utwórzmy katalog __templates__. Tam stwórzmy plik __blog-list.js__.\nNa tym etapie możesz usunąć plik __index.html__ znajdujący się w folderze __pages__, gdyż wygenerujemy go sami.\n\nZacznijmy od podstawowej struktury komponentu klasowego w React.\n\n```jsx\nblog-list.js\n\nimport React from \"react\"\nimport Layout from \"../components/layout\"\n\nclass BlogList extends React.Component {\n  render() {\n    return (\n      <Layout>\n        <h1> Oto wszystkie moje wpisy! </h1>\n      </Layout>\n    )\n  }\n}\n\nexport default BlogList\n```\n\nZaimportujmy GraphQL i utwórzmy zapytanie, które wcześniej testowaliśmy.\n\n```jsx\nimport { graphql } from 'gatsby'\n```\n\n```jsx\nconst allPagesQuery = graphql`\n  query allPagesQuery {\n    allWordpressPost {\n      edges {\n        node {\n\t  id\n          title\n          slug\n          content\n        }\n      }\n    }\n  }\n`\n```\n\nOd tej pory nasz komponent klasowy ma dostęp do odpowiedzi z zapytania za pośrednictwem __props__.\n\nUżyjmy więc destrukturyzacji, aby wyciągnąć tablicę __edges__ zawierającą wszystkie posty.\n\n```jsx\nconst { edges: posts } = this.props.data.allWordpressPost\n```\n\noraz zmapujmy te dane, aby otrzymać listę tytułów\n\n```jsx\nreturn (\n  <Layout>\n    <h1> Oto wszystkie moje wpisy! </h1>\n    <ul>\n      {posts.map(post => {\n        const { id, title } = post.node\n        return (\n          <li key={id}>\n            <h2>{title}</h2>\n          </li>\n        )\n      })}\n    </ul>\n  </Layout>\n)\n```\n\nPlikiem odpowiedzialnym za generowanie stron jest plik __gatsby-node.js__.\n\n\nZaimportujmy w nim __path__ niezbędne do podawania ścieżki do naszego szablonu.\n\n```jsx\nconst path = require(\"path\")\n```\n\nKolejnym krokiem będzie zdefiniowanie funkcji __createPages__, utworzenie zapytania graphql o wszystkie posty oraz utworzenie strony głównej przy użyciu funkcji `createPage`.\n\n```jsx\nexports.createPages = ({ actions, graphql }) => {\n  const { createPage } = actions\n\n  return graphql(`\n    {\n      allWordpressPost {\n        edges {\n          node {\n            id\n            slug\n            status\n          }\n        }\n      }\n    }\n  `).then(result => {\n    if (result.errors) {\n      result.errors.forEach(e => console.error(e.toString()))\n      return Promise.reject(result.errors)\n    }\n    const blogListTemplate = path.resolve(`./src/templates/blog-list.js`)\n    createPage({\n      path: `/`,\n      component: blogListTemplate,\n      context: {},\n    })\n  })\n}\n```\n\nTeraz wystarczy ponownie uruchomić serwer i przejść pod adres __localhost:8000__.\n\nNaszym oczom powinien ukazać się następujący widok.\n\n![](https://i.imgur.com/5itK5qN.png)\n\nAby sprawdzić, czy wszystko działa jak należy, przejdź do panelu administracyjnego Wordpress i dodaj nowy wpis. Następnie uruchom ponownie serwer. Na __localhost:8000__ powinien ukazać się tytuł nowego wpisu.\n\n![](https://i.imgur.com/0ku05h5.png)\n\n## Zdalny build projektu\n\nUtworzymy teraz plik, który pozwoli nam na zbudowanie naszego projektu bezpośrednio w repozytorium na Gitlabie.\nKonfiguracja ta sprawi, że po każdym wykonanym pushu na gałęzi __master__, wykona się __build__. Pozwoli nam to na statyczne generowanie stron bez potrzeby budowania projektu lokalnie i przenoszeniu zawartości do repozytorium zdalnego.\n\nW tym celu w głównym katalogu naszego projektu utwórzmy plik __.gitlab-ci.yml__ oraz uzupełnijmy jego zawartość według dokumentacji Gitlaba:\n\n```json\nimage: node:11.10.1\n\ncache:\n  paths:\n    - node_modules/\n\npages:\n  script:\n    - yarn install\n    - ./node_modules/.bin/gatsby build --prefix-paths\n  artifacts:\n    paths:\n      - public\n  only:\n    - master\n\n```\n\nSkrypt ten sprawi, że każdy push na gałąź __master__ wykona polecenia: __yarn install__ oraz __gatsby build__.\n\nPrzetestujmy to dodając pliki do repozytorium poleceniem \n```shell \ngit add .\ngit commit -m \"Create blog list, add .gitlab-ci.yml\"\ngit push origin master\n```\n\nPo pomyślnie wykonanym pushu wejdź na stronę\nhttps://gitlab.com/<twojanazwa>/<nazwarepozytorium>/pipelines\n\nTwoim oczom powinien ukazać się proces, który został wywołany przez Twój push. Jest to moment, w którym wykonują się polecenia zdefiniowane w pliku __.gitlab-ci.yml__.\n\nPo kilku minutach, gdy proces zakończy się pomyślnie na stronie __https://<twojanazwa>.gitlab.io/<nazwarepozytorium>__ powinna ukazać się strona z listą Twoich wpisów.\n\n> __UWAGA:__ przy pierwszym buildzie, czas do pojawienia się strony na hostingu Gitlab Pages może wydłużyć się nawet do 30 minut.\n\n## Reakcja na zmiany\n\nObecnie nasz projekt buduje się w momencie, gdy wykonamy commit i push do gałęzi master.\nKażdorazowy push po zmianach to niesamowicie niewygodne rozwiązanie. Istnieje jednak możliwość, aby wywołać build w odpowiedzi na zmiany dokonane w panelu administracyjnym Wordpress.\n\nW tym celu posłużymy się pluginem [wordpress-gitlab-trigger-pipeline](https://github.com/kmturley/wordpress-gitlab-trigger-pipeline).\n\n> Ma tylko __JEDNĄ__ gwiazdkę na Githubie. Zróbmy coś z tym.\n\nIdąc za plikiem README, w naszym folderze Wordpressa przechodzimy do __wp_content/plugins__ i wklejamy tam plik __gitlab-trigger-pipeline.php__, który możemy pobrać z powyższego repozytorium.\n\nNastępnie przechodzimy do panelu administracyjnego Wordpress do zakładki __Wtyczki__ i w sekcji __zainstalowane wtyczki__ aktywujemy dodany przez nas plugin.\n\nW repozytorium Gitlab przechodzimy do zakładki __Settings__ -> __CI/CD__ i rozwijamy sekcję __Pipeline triggers__.\n\nTworzymy nowy trigger, nadając mu dowolny opis i naciskając przycisk __Add trigger__.\n\nOtrzymany token kopiujemy do schowka i wracamy do panelu administracyjnego Wordpress.\n\nW zakładce __Ustawienia__ ujrzymy dodatkowe opcje, które pojawiły się za sprawą aktywacji nowego pluginu.\nUzupełniamy je następująco:\n__GITLAB BRANCH:__ master\n__GITLAB ID:__ id repozytorium (do znalezienia pod nazwą na stronie głównej repozytorium)\n__GITLAB TRIGGER TOKEN:__ <token skopiowany do schowka>\n\n![](https://i.imgur.com/FxX2DeD.png)\n\n\nOd tego momentu każdy nowy wpis spowoduje, że w sekcji __Pipelines__ w repozytorium na Gitlab uruchomi się skrypt z buildem i po kilku minutach ujrzymy kolejny tytuł wpisu na naszej stronie.\n\n## Podstrony wpisów\n\nZajmiemy się teraz wygenerowaniem stron statycznych dla każdego z naszych wpisów. Zmodyfikujemy więc stronę główną, dodając do tytułu wpisu odnośnik, który powinien prowadzić do strony z treścią.\n\nPo modyfikacji komponent w pliku __blog-list.js__ będzie wyglądał następująco\n\n```jsx\nblog-list.js\n\nclass BlogList extends React.Component {\n  render() {\n    const { edges: posts } = this.props.data.allWordpressPost\n    return (\n      <Layout>\n        <h1> Oto wszystkie moje wpisy! </h1>\n        <ul>\n          {posts.map(post => {\n            const { id, title, content, slug } = post.node\n            return (\n              <li key={id}>\n                <h2>{title}</h2>\n                <Link to={`/${slug}`}>Czytaj więcej</Link>\n              </li>\n            )\n          })}\n        </ul>\n      </Layout>\n    )\n  }\n}\n```\n\nPo uruchomieniu serwera faktycznie zauważymy dodane odnośniki.\n\n![](https://i.imgur.com/qSzqD9u.png)\n\nKażdy z nich przenosi odpowiednio do postron: _/oto-kolejny-wpis_, _moj-drugi-wpis_, _witaj-swiecie_, jednak z racji, że nie wskazaliśmy jeszcze Gatsbiemu jak ma generować strony, po kliknięciu w odnośniki otrzymamy błąd 404.\n\nKolejnym krokiem będzie utworzenie nowego szablonu, na podstawie którego wygenerujemy podstrony.\n\nW tym celu w folderze __src/templates__ utwórzmy plik __blog-post.js__.\n\nWewnątrz pliku utwórzmy komponent funkcyjny o nazwie BlogPost i uzupełnijmy go przykładową treścią.\n\n```jsx\nblog-post.js\n\nimport React from \"react\"\nimport { graphql } from \"gatsby\"\n\nconst BlogPost = () => {\n  return <h1> Oto podstrona dla wpisu na blogu! </h1>\n}\n\nexport default BlogPost\n```\n\nTyle wystarczy, aby zająć się generowaniem podstron.\n\nJak pamiętasz, w pliku __gatsby-node.js__ napisaliśmy już jedno zapytanie graphql, które zwróci nam wszystkie nasze posty.\n\nDla każdego otrzymanego posta, musimy wywołać funkcję `createPage` z odpowiednimi parametrami w następujący sposób:\n\n```jsx\nblog-post.js\n\nconst blogPostTemplate = path.resolve(\"./src/templates/blog-post.js\")\nconst posts = result.data.allWordpressPage.edges\nposts.forEach(({ node: page }) => {\n  createPage({\n    path: `${page.slug}`,\n    component: blogPostTemplate,\n    context: {\n      id: page.id,\n    },\n  })\n})\n```\n\nPo ponownym uruchomieniu serwera, dla każdego wpisu powstanie strona z treścią _Oto podstrona dla wpisu na blogu!_\n\nTeraz należy uzupełnić szablon postu tak, aby pobierał konkretne informacje. Jak mogłeś zauważyć, w wywołaniu funkcji `createPage` w obiekcie __context__ przekazujemy __id__ danego wpisu. Posłuży nam ono teraz, aby utworzyć zapytanie o wpis związany z tym id.\n\nW pliku __blog-post.js__:\n\n```jsx\nblog-post.js\n\nexport const pageQuery = graphql`\n  query BlogPostByID($id: String!) {\n    wordpressPost(id: { eq: $id }) {\n      id\n      title\n      slug\n      content\n      date(formatString: \"MMMM DD, YYYY\")\n    }\n  }\n`\n```\n\nPozostaje nam tylko zmodyfikować komponent\n\n```jsx\nblog-post.js\n\nconst BlogPost = props => {\n  const { title, date, content } = props.data.wordpressPost\n  return (\n    <div>\n      <h1>{title}</h1>\n      <p>{date}</p>\n      <div dangerouslySetInnerHTML={{ __html: content }} />\n    </div>\n  )\n}\n```\n\n> Dane zwrócone w polu __content__ są opatrzone w znaczniki html, co sprawia, że w celu ich poprawnego sformatowania musimy przekazać je jako parametry __dangerouslySetInnerHTML__.\n\nPo ponownym uruchomieniu serwera podstrony dla każdego wpisu powinny ukazywać odpowiednią treść.\n\n> __UWAGA:__ Z racji, że nasza strona może być hostowana pod linkiem zawierającym prefix (w moim przypadku jest to _mywordpressblog_), informację o tym prefixie należy umieścić w pliku __gatsby-config.js__, dopisując do obiektu module.exports właściwość pathPrefix.\n```json\nmodule.exports = {\n  pathPrefix: `/mywordpressblog`,\n}\n```\n\nTak oto otrzymujemy w pełni sprawny blog, który pozwala nam na zarządzanie treścia z poziomu systemu zarządzania treścią Wordpress.\n\nW celu dodatkowej pomocy, udostępniam dla Ciebie dostęp do [repozytorium](https://gitlab.com/wglugla/mywordpressblog), które posłużyło mi do napisania tego artykułu oraz [podgląd](https://wglugla.gitlab.io/mywordpressblog/) finalnej wersji zbudowanego bloga.","tags":"[\n  \"gatsby\",\n  \"wordpress\"\n]","slug":"porozumienie-gatsby-wordpress"}},"pageContext":{"slug":"porozumienie-gatsby-wordpress","previous":null,"next":{"slug":"nadazyc-za-skryptami-na-stronie-tag-script-i-jego-atrybuty","title":"Nadążyć za skryptami na stronie - tag script i jego atrybuty"}}},"staticQueryHashes":["3649515864","63159454"]}